#include "world.hpp"
#include <math.h>
#include <stdlib.h>
#include <vector>

// Helper for Color
// Raylib Color is {r, g, b, a}
static Color MakeColor(unsigned char r, unsigned char g, unsigned char b,
                       unsigned char a) {
  Color c;
  c.r = r;
  c.g = g;
  c.b = b;
  c.a = a;
  return c;
}

World::World() {
  // Constructor
}

void World::Init() {
  // 1. Generate Textures (Procedural)
  // GRASS
  Image imgGrass = GenImageColor(16, 16, GREEN);
  ImageColorReplace(&imgGrass, GREEN, MakeColor(34, 139, 34, 255));
  for (int i = 0; i < 64; i++)
    ImageDrawPixel(&imgGrass, rand() % 16, rand() % 16,
                   MakeColor(50, 205, 50, 255));
  blockTextures[BLOCK_GRASS] = LoadTextureFromImage(imgGrass);

  // DIRT
  Image imgDirt = GenImageColor(16, 16, BROWN);
  for (int i = 0; i < 64; i++)
    ImageDrawPixel(&imgDirt, rand() % 16, rand() % 16,
                   MakeColor(100, 50, 20, 255));
  blockTextures[BLOCK_DIRT] = LoadTextureFromImage(imgDirt);

  // STONE
  Image imgStone = GenImageColor(16, 16, DARKGRAY);
  for (int i = 0; i < 100; i++)
    ImageDrawPixel(&imgStone, rand() % 16, rand() % 16,
                   MakeColor(100, 100, 100, 255));
  blockTextures[BLOCK_STONE] = LoadTextureFromImage(imgStone);

  // WOOD
  Image imgWood = GenImageColor(16, 16, MakeColor(139, 69, 19, 255));
  ImageDrawLine(&imgWood, 4, 0, 4, 16, MakeColor(160, 82, 45, 255));
  ImageDrawLine(&imgWood, 10, 0, 10, 16, MakeColor(120, 50, 10, 255));
  blockTextures[BLOCK_WOOD] = LoadTextureFromImage(imgWood);

  // SAND
  Image imgSand = GenImageColor(16, 16, BEIGE);
  for (int i = 0; i < 50; i++)
    ImageDrawPixel(&imgSand, rand() % 16, rand() % 16, GOLD);
  blockTextures[BLOCK_SAND] = LoadTextureFromImage(imgSand);

  // LEAVES
  Image imgLeaves = GenImageColor(16, 16, MakeColor(0, 100, 0, 255));
  for (int i = 0; i < 40; i++)
    ImageDrawPixel(&imgLeaves, rand() % 16, rand() % 16,
                   MakeColor(0, 150, 0, 255));
  blockTextures[BLOCK_LEAVES] = LoadTextureFromImage(imgLeaves);

  // WATER
  Image imgWater = GenImageColor(16, 16, BLUE);
  ImageAlphaClear(&imgWater, MakeColor(0, 0, 255, 150), 0.5f);
  for (int i = 0; i < 40; i++)
    ImageDrawPixel(&imgWater, rand() % 16, rand() % 16,
                   MakeColor(0, 191, 255, 200));
  blockTextures[BLOCK_WATER] = LoadTextureFromImage(imgWater);

  blockTextures[BLOCK_AIR] = blockTextures[BLOCK_DIRT];

  // 2. Build Atlas
  // 128x128 pixels. 8 blocks per row.
  Image atlasImg = GenImageColor(128, 128, BLANK);

  // Copy images to atlas
  // Order must match BlockType enum
  // 1: DIRT -> 0,0
  // 2: GRASS -> 16,0
  // ...
  // We'll iterate enum 1 to 7
  ImageDraw(&atlasImg, imgDirt, (Rectangle){0, 0, 16, 16},
            (Rectangle){16 * 1, 0, 16, 16}, WHITE);
  ImageDraw(&atlasImg, imgGrass, (Rectangle){0, 0, 16, 16},
            (Rectangle){16 * 2, 0, 16, 16}, WHITE);
  ImageDraw(&atlasImg, imgStone, (Rectangle){0, 0, 16, 16},
            (Rectangle){16 * 3, 0, 16, 16}, WHITE);
  ImageDraw(&atlasImg, imgWood, (Rectangle){0, 0, 16, 16},
            (Rectangle){16 * 4, 0, 16, 16}, WHITE);
  ImageDraw(&atlasImg, imgSand, (Rectangle){0, 0, 16, 16},
            (Rectangle){16 * 5, 0, 16, 16}, WHITE);
  ImageDraw(&atlasImg, imgLeaves, (Rectangle){0, 0, 16, 16},
            (Rectangle){16 * 6, 0, 16, 16}, WHITE);
  ImageDraw(&atlasImg, imgWater, (Rectangle){0, 0, 16, 16},
            (Rectangle){16 * 7, 0, 16, 16}, WHITE);

  atlasTexture = LoadTextureFromImage(atlasImg);
  UnloadImage(atlasImg);

  // Unload source images
  UnloadImage(imgGrass);
  UnloadImage(imgDirt);
  UnloadImage(imgStone);
  UnloadImage(imgWood);
  UnloadImage(imgSand);
  UnloadImage(imgLeaves);
  UnloadImage(imgWater);

  // 3. Clear World
  for (int x = 0; x < WORLD_WIDTH; x++) {
    for (int y = 0; y < WORLD_HEIGHT; y++) {
      for (int z = 0; z < WORLD_DEPTH; z++) {
        grid[x][y][z].active = false;
        grid[x][y][z].type = BLOCK_AIR;
      }
    }
  }

  // 4. Init Chunks
  for (int cx = 0; cx < WORLD_WIDTH / CHUNK_SIZE; cx++) {
    for (int cy = 0; cy < WORLD_HEIGHT / CHUNK_SIZE; cy++) {
      for (int cz = 0; cz < WORLD_DEPTH / CHUNK_SIZE; cz++) {
        chunks[cx][cy][cz].active = false;
        chunks[cx][cy][cz].dirty = false;
        chunks[cx][cy][cz].model = {0};
      }
    }
  }

  // 5. Generate Terrain
  GenerateTerrain();

  // 6. Mark dirty
  for (int cx = 0; cx < WORLD_WIDTH / CHUNK_SIZE; cx++) {
    for (int cy = 0; cy < WORLD_HEIGHT / CHUNK_SIZE; cy++) {
      for (int cz = 0; cz < WORLD_DEPTH / CHUNK_SIZE; cz++) {
        chunks[cx][cy][cz].dirty = true;
      }
    }
  }
}

void World::Unload() {
  for (int i = 1; i < 8; i++) {
    UnloadTexture(blockTextures[i]);
  }
  UnloadTexture(atlasTexture);

  for (int cx = 0; cx < WORLD_WIDTH / CHUNK_SIZE; cx++) {
    for (int cy = 0; cy < WORLD_HEIGHT / CHUNK_SIZE; cy++) {
      for (int cz = 0; cz < WORLD_DEPTH / CHUNK_SIZE; cz++) {
        if (chunks[cx][cy][cz].active) {
          if (chunks[cx][cy][cz].model.meshCount > 0) {
            UnloadModel(chunks[cx][cy][cz].model);
          }
        }
      }
    }
  }
}

Texture2D World::GetBlockTexture(BlockType type) {
  if (type < 0 || type > 9)
    return blockTextures[BLOCK_DIRT];
  return blockTextures[type];
}

void World::GenerateTerrain() {
  // Smoother noise for hills - much lower frequency for "cleaner" look
  // Increased scale to 200.0f means hills are very wide and gentle.
  Image noiseMap = GenImagePerlinNoise(WORLD_WIDTH, WORLD_DEPTH, 0, 0, 2.0f);
  Color *pixels = LoadImageColors(noiseMap);

  Vector2 center = {WORLD_WIDTH / 2.0f, WORLD_DEPTH / 2.0f};
  float maxDist = WORLD_WIDTH / 2.0f; // Radius

  for (int x = 0; x < WORLD_WIDTH; x++) {
    for (int z = 0; z < WORLD_DEPTH; z++) {
      float noiseVal = pixels[z * WORLD_WIDTH + x].r / 255.0f;

      // ISLAND MASK
      float distBox =
          fmax(fabs(x - center.x), fabs(z - center.y)); // Square mask
      float distCircle = sqrtf(pow(x - center.x, 2) + pow(z - center.y, 2));
      // Blend square and circle for rounded square island
      float dist = (distBox + distCircle) * 0.5f;

      float gradient = 1.0f - (dist / maxDist); // 1.0 at center, 0.0 at edge
      gradient = pow(gradient, 0.5f); // Curve it to keep center flat-ish
      if (gradient < 0)
        gradient = 0;

      // Lower height multiplier for flatter terrain
      // +6 offset ensures land is generally above water level (Y=6)
      int height = (int)(noiseVal * 15.0f * gradient) + 6;

      for (int y = 0; y <= height; y++) {
        BlockType type = BLOCK_DIRT;
        if (y == height)
          type = BLOCK_GRASS;
        if (y < height - 3)
          type = BLOCK_STONE;
        if (y == height && y <= 7) // Sand beaches near water level
          type = BLOCK_SAND;

        SetBlock(x, y, z, true, type);
      }

      // Water Level at Y=6
      for (int y = 0; y <= 6; y++) {
        if (!grid[x][y][z].active) {
          SetBlock(x, y, z, true, BLOCK_WATER);
        }
      }

      // Trees (Only on Grass and not too close to water)
      if (grid[x][height][z].active && grid[x][height][z].type == BLOCK_GRASS &&
          height > 7 && (rand() % 100) < 1) { // 1% chance for cleaner look
        GenerateTree(x, height + 1, z);
      }
    }
  }
  UnloadImageColors(pixels);
  UnloadImage(noiseMap);
}

void World::GenerateTree(int x, int y, int z) {
  if (x < 2 || x >= WORLD_WIDTH - 2 || z < 2 || z >= WORLD_DEPTH - 2 ||
      y >= WORLD_HEIGHT - 8)
    return;
  int treeHeight = 4 + rand() % 3;
  for (int i = 0; i < treeHeight; i++)
    SetBlock(x, y + i, z, true, BLOCK_WOOD);

  for (int lx = x - 2; lx <= x + 2; lx++) {
    for (int lz = z - 2; lz <= z + 2; lz++) {
      for (int ly = y + treeHeight - 2; ly <= y + treeHeight + 1; ly++) {
        if (abs(lx - x) + abs(ly - (y + treeHeight)) + abs(lz - z) <= 3) {
          if (!grid[lx][ly][lz].active)
            SetBlock(lx, ly, lz, true, BLOCK_LEAVES);
        }
      }
    }
  }
}

void World::Update() {
  int rebuildCount = 0;
  for (int cx = 0; cx < WORLD_WIDTH / CHUNK_SIZE; cx++) {
    for (int cy = 0; cy < WORLD_HEIGHT / CHUNK_SIZE; cy++) {
      for (int cz = 0; cz < WORLD_DEPTH / CHUNK_SIZE; cz++) {
        if (chunks[cx][cy][cz].dirty) {
          RebuildChunk(cx, cy, cz);
          rebuildCount++;
          if (rebuildCount > 8)
            return;
        }
      }
    }
  }
}

// Rebuilds a specific chunk mesh
void World::RebuildChunk(int cx, int cy, int cz) {
  Chunk &chunk = chunks[cx][cy][cz];

  // Cleanup old model
  if (chunk.active) {
    UnloadModel(chunk.model);
    chunk.active = false;
    chunk.model = {0};
  }
  chunk.dirty = false;

  // Geometry Generation
  // Arrays for mesh construction
  // Estimate size? 16*16*16 * 6 faces * 6 verts = 24k verts max.
  // std::vector is fine.
  std::vector<Vector3> vertices;
  std::vector<Vector2> texcoords;
  std::vector<Vector3> normals;

  int startX = cx * CHUNK_SIZE;
  int startY = cy * CHUNK_SIZE;
  int startZ = cz * CHUNK_SIZE;
  int endX = startX + CHUNK_SIZE;
  int endY = startY + CHUNK_SIZE;
  int endZ = startZ + CHUNK_SIZE;

  if (endX > WORLD_WIDTH)
    endX = WORLD_WIDTH;
  if (endY > WORLD_HEIGHT)
    endY = WORLD_HEIGHT;
  if (endZ > WORLD_DEPTH)
    endZ = WORLD_DEPTH;

  // Unit size UV
  float uvStep = 1.0f / 8.0f; // 8 blocks matches width 128 (16px * 8)

  for (int x = startX; x < endX; x++) {
    for (int y = startY; y < endY; y++) {
      for (int z = startZ; z < endZ; z++) {
        if (!grid[x][y][z].active)
          continue;

        BlockType type = grid[x][y][z].type;
        float u = (int)type * uvStep;
        float v = 0.0f;

        // Check neighbors
        // TOP (Y+)
        if (y == WORLD_HEIGHT - 1 || !grid[x][y + 1][z].active ||
            (grid[x][y + 1][z].type == BLOCK_LEAVES && type != BLOCK_LEAVES)) {
          // Add Top Face
          vertices.push_back((Vector3){(float)x, (float)y + 1, (float)z}); // TL
          vertices.push_back(
              (Vector3){(float)x, (float)y + 1, (float)z + 1}); // BL
          vertices.push_back(
              (Vector3){(float)x + 1, (float)y + 1, (float)z + 1}); // BR

          vertices.push_back((Vector3){(float)x, (float)y + 1, (float)z}); // TL
          vertices.push_back(
              (Vector3){(float)x + 1, (float)y + 1, (float)z + 1}); // BR
          vertices.push_back(
              (Vector3){(float)x + 1, (float)y + 1, (float)z}); // TR

          for (int k = 0; k < 6; k++)
            normals.push_back((Vector3){0, 1, 0});

          texcoords.push_back((Vector2){u, v});
          texcoords.push_back(
              (Vector2){u, v + 1.0f}); // Full height? No 16/128 = 0.125
          // Atlas is 128x128. Textures are 16x16.
          // V range is 0 to 0.125
          // U range is u to u+0.125
          float vH = 0.125f;
          float uW = 0.125f;

          // Fix UVs to match vertices order
          // TL, BL, BR, TL, BR, TR
          texcoords.pop_back();
          texcoords.pop_back(); // Remove placeholder

          texcoords.push_back((Vector2){u, v});           // TL
          texcoords.push_back((Vector2){u, v + vH});      // BL
          texcoords.push_back((Vector2){u + uW, v + vH}); // BR

          texcoords.push_back((Vector2){u, v});           // TL
          texcoords.push_back((Vector2){u + uW, v + vH}); // BR
          texcoords.push_back((Vector2){u + uW, v});      // TR
        }

        // BOTTOM (Y-)
        if (y == 0 || !grid[x][y - 1][z].active ||
            (grid[x][y - 1][z].type == BLOCK_LEAVES && type != BLOCK_LEAVES)) {
          vertices.push_back((Vector3){(float)x, (float)y, (float)z + 1});
          vertices.push_back((Vector3){(float)x, (float)y, (float)z});
          vertices.push_back((Vector3){(float)x + 1, (float)y, (float)z});

          vertices.push_back((Vector3){(float)x, (float)y, (float)z + 1});
          vertices.push_back((Vector3){(float)x + 1, (float)y, (float)z});
          vertices.push_back((Vector3){(float)x + 1, (float)y, (float)z + 1});

          for (int k = 0; k < 6; k++)
            normals.push_back((Vector3){0, -1, 0});

          float vH = 0.125f;
          float uW = 0.125f;
          texcoords.push_back((Vector2){u, v + vH});
          texcoords.push_back((Vector2){u, v});
          texcoords.push_back((Vector2){u + uW, v});

          texcoords.push_back((Vector2){u, v + vH});
          texcoords.push_back((Vector2){u + uW, v});
          texcoords.push_back((Vector2){u + uW, v + vH});
        }

        // FRONT (Z+)
        if (z == WORLD_DEPTH - 1 || !grid[x][y][z + 1].active ||
            (grid[x][y][z + 1].type == BLOCK_LEAVES && type != BLOCK_LEAVES)) {
          vertices.push_back((Vector3){(float)x, (float)y, (float)z + 1});
          vertices.push_back((Vector3){(float)x, (float)y + 1, (float)z + 1});
          vertices.push_back(
              (Vector3){(float)x + 1, (float)y + 1, (float)z + 1});

          vertices.push_back((Vector3){(float)x, (float)y, (float)z + 1});
          vertices.push_back(
              (Vector3){(float)x + 1, (float)y + 1, (float)z + 1});
          vertices.push_back((Vector3){(float)x + 1, (float)y, (float)z + 1});

          for (int k = 0; k < 6; k++)
            normals.push_back((Vector3){0, 0, 1});

          float vH = 0.125f;
          float uW = 0.125f;
          texcoords.push_back((Vector2){u, v + vH});
          texcoords.push_back((Vector2){u, v});
          texcoords.push_back((Vector2){u + uW, v});

          texcoords.push_back((Vector2){u, v + vH});
          texcoords.push_back((Vector2){u + uW, v});
          texcoords.push_back((Vector2){u + uW, v + vH});
        }

        // BACK (Z-)
        if (z == 0 || !grid[x][y][z - 1].active ||
            (grid[x][y][z - 1].type == BLOCK_LEAVES && type != BLOCK_LEAVES)) {
          vertices.push_back((Vector3){(float)x + 1, (float)y, (float)z});
          vertices.push_back((Vector3){(float)x + 1, (float)y + 1, (float)z});
          vertices.push_back((Vector3){(float)x, (float)y + 1, (float)z});

          vertices.push_back((Vector3){(float)x + 1, (float)y, (float)z});
          vertices.push_back((Vector3){(float)x, (float)y + 1, (float)z});
          vertices.push_back((Vector3){(float)x, (float)y, (float)z});

          for (int k = 0; k < 6; k++)
            normals.push_back((Vector3){0, 0, -1});

          float vH = 0.125f;
          float uW = 0.125f;
          texcoords.push_back((Vector2){u + uW, v + vH});
          texcoords.push_back((Vector2){u + uW, v});
          texcoords.push_back((Vector2){u, v});

          texcoords.push_back((Vector2){u + uW, v + vH});
          texcoords.push_back((Vector2){u, v});
          texcoords.push_back((Vector2){u, v + vH});
        }

        // LEFT (X-)
        if (x == 0 || !grid[x - 1][y][z].active ||
            (grid[x - 1][y][z].type == BLOCK_LEAVES && type != BLOCK_LEAVES)) {
          vertices.push_back((Vector3){(float)x, (float)y, (float)z});
          vertices.push_back((Vector3){(float)x, (float)y + 1, (float)z});
          vertices.push_back((Vector3){(float)x, (float)y + 1, (float)z + 1});

          vertices.push_back((Vector3){(float)x, (float)y, (float)z});
          vertices.push_back((Vector3){(float)x, (float)y + 1, (float)z + 1});
          vertices.push_back((Vector3){(float)x, (float)y, (float)z + 1});

          for (int k = 0; k < 6; k++)
            normals.push_back((Vector3){-1, 0, 0});

          float vH = 0.125f;
          float uW = 0.125f;
          texcoords.push_back((Vector2){u, v + vH});
          texcoords.push_back((Vector2){u, v});
          texcoords.push_back((Vector2){u + uW, v});

          texcoords.push_back((Vector2){u, v + vH});
          texcoords.push_back((Vector2){u + uW, v});
          texcoords.push_back((Vector2){u + uW, v + vH});
        }

        // RIGHT (X+)
        if (x == WORLD_WIDTH - 1 || !grid[x + 1][y][z].active ||
            (grid[x + 1][y][z].type == BLOCK_LEAVES && type != BLOCK_LEAVES)) {
          vertices.push_back((Vector3){(float)x + 1, (float)y, (float)z + 1});
          vertices.push_back(
              (Vector3){(float)x + 1, (float)y + 1, (float)z + 1});
          vertices.push_back((Vector3){(float)x + 1, (float)y + 1, (float)z});

          vertices.push_back((Vector3){(float)x + 1, (float)y, (float)z + 1});
          vertices.push_back((Vector3){(float)x + 1, (float)y + 1, (float)z});
          vertices.push_back((Vector3){(float)x + 1, (float)y, (float)z});

          for (int k = 0; k < 6; k++)
            normals.push_back((Vector3){1, 0, 0});

          float vH = 0.125f;
          float uW = 0.125f;
          texcoords.push_back((Vector2){u, v + vH});
          texcoords.push_back((Vector2){u, v});
          texcoords.push_back((Vector2){u + uW, v});

          texcoords.push_back((Vector2){u, v + vH});
          texcoords.push_back((Vector2){u + uW, v});
          texcoords.push_back((Vector2){u + uW, v + vH});
        }
      }
    }
  }

  if (vertices.empty()) {
    chunk.active = false;
    return;
  }

  // Convert vector to Mesh
  Mesh mesh = {0};
  mesh.vertexCount = vertices.size();
  mesh.triangleCount = vertices.size() / 3;

  // Allocate memory
  mesh.vertices = (float *)MemAlloc(mesh.vertexCount * 3 * sizeof(float));
  mesh.texcoords = (float *)MemAlloc(mesh.vertexCount * 2 * sizeof(float));
  mesh.normals = (float *)MemAlloc(mesh.vertexCount * 3 * sizeof(float));

  // Fill data
  for (size_t i = 0; i < vertices.size(); i++) {
    mesh.vertices[i * 3] = vertices[i].x;
    mesh.vertices[i * 3 + 1] = vertices[i].y;
    mesh.vertices[i * 3 + 2] = vertices[i].z;

    mesh.normals[i * 3] = normals[i].x;
    mesh.normals[i * 3 + 1] = normals[i].y;
    mesh.normals[i * 3 + 2] = normals[i].z;

    mesh.texcoords[i * 2] = texcoords[i].x;
    mesh.texcoords[i * 2 + 1] = texcoords[i].y;
  }

  UploadMesh(&mesh, false);

  chunk.model = LoadModelFromMesh(mesh);
  chunk.model.materials[0].maps[MATERIAL_MAP_DIFFUSE].texture = atlasTexture;
  chunk.active = true;
}

void World::Draw() {
  for (int cx = 0; cx < WORLD_WIDTH / CHUNK_SIZE; cx++) {
    for (int cy = 0; cy < WORLD_HEIGHT / CHUNK_SIZE; cy++) {
      for (int cz = 0; cz < WORLD_DEPTH / CHUNK_SIZE; cz++) {
        if (chunks[cx][cy][cz].active) {
          DrawModel(chunks[cx][cy][cz].model, (Vector3){0, 0, 0}, 1.0f, WHITE);
        }
      }
    }
  }
}

Block World::GetBlock(int x, int y, int z) {
  if (x >= 0 && x < WORLD_WIDTH && y >= 0 && y < WORLD_HEIGHT && z >= 0 &&
      z < WORLD_DEPTH) {
    return grid[x][y][z];
  }
  return {false, BLOCK_AIR};
}

World::WorldRayHit World::GetRayCollision(Ray ray) {
  WorldRayHit closestHit = {false};
  closestHit.distance = 999999.0f;

  int cx = (int)ray.position.x;
  int cy = (int)ray.position.y;
  int cz = (int)ray.position.z;
  int radius = 8;

  int minX = cx - radius;
  if (minX < 0)
    minX = 0;
  int maxX = cx + radius;
  if (maxX >= WORLD_WIDTH)
    maxX = WORLD_WIDTH - 1;
  int minY = cy - radius;
  if (minY < 0)
    minY = 0;
  int maxY = cy + radius;
  if (maxY >= WORLD_HEIGHT)
    maxY = WORLD_HEIGHT - 1;
  int minZ = cz - radius;
  if (minZ < 0)
    minZ = 0;
  int maxZ = cz + radius;
  if (maxZ >= WORLD_DEPTH)
    maxZ = WORLD_DEPTH - 1;

  for (int x = minX; x <= maxX; x++) {
    for (int y = minY; y <= maxY; y++) {
      for (int z = minZ; z <= maxZ; z++) {
        if (!grid[x][y][z].active)
          continue;

        BoundingBox box = {
            (Vector3){(float)x - 0.5f, (float)y - 0.5f, (float)z - 0.5f},
            (Vector3){(float)x + 0.5f, (float)y + 0.5f, (float)z + 0.5f}};

        RayCollision collision = GetRayCollisionBox(ray, box);
        if (collision.hit && collision.distance < closestHit.distance) {
          closestHit.hit = true;
          closestHit.distance = collision.distance;
          closestHit.x = x;
          closestHit.y = y;
          closestHit.z = z;
          closestHit.normal = collision.normal;
        }
      }
    }
  }
  return closestHit;
}

void World::SetBlock(int x, int y, int z, bool active, BlockType type) {
  if (x >= 0 && x < WORLD_WIDTH && y >= 0 && y < WORLD_HEIGHT && z >= 0 &&
      z < WORLD_DEPTH) {
    grid[x][y][z].active = active;
    grid[x][y][z].type = type;

    int cx = x / CHUNK_SIZE;
    int cy = y / CHUNK_SIZE;
    int cz = z / CHUNK_SIZE;
    if (cx >= 0 && cx < WORLD_WIDTH / CHUNK_SIZE && cy >= 0 &&
        cy < WORLD_HEIGHT / CHUNK_SIZE && cz >= 0 &&
        cz < WORLD_DEPTH / CHUNK_SIZE) {
      chunks[cx][cy][cz].dirty = true;

      if (x % CHUNK_SIZE == 0 && cx > 0)
        chunks[cx - 1][cy][cz].dirty = true;
      if (x % CHUNK_SIZE == CHUNK_SIZE - 1 && cx < WORLD_WIDTH / CHUNK_SIZE - 1)
        chunks[cx + 1][cy][cz].dirty = true;
      if (y % CHUNK_SIZE == 0 && cy > 0)
        chunks[cx][cy - 1][cz].dirty = true;
      if (y % CHUNK_SIZE == CHUNK_SIZE - 1 &&
          cy < WORLD_HEIGHT / CHUNK_SIZE - 1)
        chunks[cx][cy + 1][cz].dirty = true;
      if (z % CHUNK_SIZE == 0 && cz > 0)
        chunks[cx][cy][cz - 1].dirty = true;
      if (z % CHUNK_SIZE == CHUNK_SIZE - 1 && cz < WORLD_DEPTH / CHUNK_SIZE - 1)
        chunks[cx][cy][cz + 1].dirty = true;
    }
  }
}
